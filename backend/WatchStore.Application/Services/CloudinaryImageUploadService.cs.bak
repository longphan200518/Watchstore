using CloudinaryDotNet;
using CloudinaryDotNet.Actions;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using WatchStore.Application.Interfaces;

namespace WatchStore.Application.Services
{
    public class CloudinaryImageUploadService : IImageUploadService
    {
        private readonly Cloudinary _cloudinary;
        private readonly IConfiguration _configuration;

        public CloudinaryImageUploadService(IConfiguration configuration)
        {
            _configuration = configuration;

            var cloudName = configuration["Cloudinary:CloudName"];
            var apiKey = configuration["Cloudinary:ApiKey"];
            var apiSecret = configuration["Cloudinary:ApiSecret"];

            if (string.IsNullOrEmpty(cloudName) || string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(apiSecret))
            {
                throw new Exception("Cloudinary configuration is missing. Please add Cloudinary settings to appsettings.json");
            }

            var account = new Account(cloudName, apiKey, apiSecret);
            _cloudinary = new Cloudinary(account);
        }

        public async Task<string> UploadImageAsync(IFormFile file, string folder = "general")
        {
            if (file == null || file.Length == 0)
                throw new ArgumentException("File is empty");

            // Validate file type
            var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".webp" };
            var extension = Path.GetExtension(file.FileName).ToLowerInvariant();
            
            if (!allowedExtensions.Contains(extension))
                throw new ArgumentException($"Invalid file type. Allowed types: {string.Join(", ", allowedExtensions)}");

            // Validate file size (max 5MB)
            if (file.Length > 5 * 1024 * 1024)
                throw new ArgumentException("File size must be less than 5MB");

            using var stream = file.OpenReadStream();

            var uploadParams = new ImageUploadParams
            {
                File = new FileDescription(file.FileName, stream),
                Folder = $"watchstore/{folder}",
                Transformation = new Transformation()
                    .Width(1200)
                    .Height(1200)
                    .Crop("limit")
                    .Quality("auto:good")
                    .FetchFormat("auto"),
                UniqueFilename = true,
                UseFilename = true
            };

            var uploadResult = await _cloudinary.UploadAsync(uploadParams);

            if (uploadResult.Error != null)
                throw new Exception($"Image upload failed: {uploadResult.Error.Message}");

            return uploadResult.SecureUrl.ToString();
        }

        public async Task<List<string>> UploadMultipleImagesAsync(List<IFormFile> files, string folder = "general")
        {
            var uploadTasks = files.Select(file => UploadImageAsync(file, folder));
            var results = await Task.WhenAll(uploadTasks);
            return results.ToList();
        }

        public async Task<bool> DeleteImageAsync(string imageUrl)
        {
            try
            {
                // Extract public ID from URL
                var publicId = ExtractPublicIdFromUrl(imageUrl);
                
                if (string.IsNullOrEmpty(publicId))
                    return false;

                var deletionParams = new DeletionParams(publicId);
                var result = await _cloudinary.DestroyAsync(deletionParams);

                return result.Result == "ok";
            }
            catch
            {
                return false;
            }
        }

        public async Task<bool> DeleteMultipleImagesAsync(List<string> imageUrls)
        {
            var deleteTasks = imageUrls.Select(DeleteImageAsync);
            var results = await Task.WhenAll(deleteTasks);
            return results.All(r => r);
        }

        private string? ExtractPublicIdFromUrl(string imageUrl)
        {
            try
            {
                // Cloudinary URL format: https://res.cloudinary.com/{cloud_name}/image/upload/v{version}/{public_id}.{format}
                var uri = new Uri(imageUrl);
                var segments = uri.AbsolutePath.Split('/');
                
                // Find "upload" segment and get everything after it
                var uploadIndex = Array.IndexOf(segments, "upload");
                if (uploadIndex == -1 || uploadIndex >= segments.Length - 1)
                    return null;

                // Skip version (v1234567890)
                var startIndex = uploadIndex + 1;
                if (segments[startIndex].StartsWith("v") && long.TryParse(segments[startIndex].Substring(1), out _))
                    startIndex++;

                // Get public ID (everything after version, without file extension)
                var publicIdWithExtension = string.Join("/", segments.Skip(startIndex));
                var lastDotIndex = publicIdWithExtension.LastIndexOf('.');
                
                return lastDotIndex > 0 ? publicIdWithExtension.Substring(0, lastDotIndex) : publicIdWithExtension;
            }
            catch
            {
                return null;
            }
        }
    }
}
